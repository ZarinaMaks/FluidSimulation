////////// Правила оформления кода на С++ ////////////////////////////////////
// В этом файле представлены основные рекомендации по организации кода на   //
// языке С++.                                                               //
//////////////////////////////////////////////////////////////////////////////

1)  Имена, представляющие типы, должны быть обязательно написаны в смешанном 
    регистре, начиная с верхнего.
    
        Line, SavingsAccount...
    
2)  Имена переменных должны быть записаны в смешанном регистре, начиная с 
    нижнего.
    
        line, savingsAccount...
    
3)  Именованные константы (включая значения перечислений) должны быть 
    записаны в верхнем регистре с нижним подчёркиванием в качестве 
    разделителя.
    
        MAX_ITERATIONS, COLOR_RED, PI...
    
4)  Названия методов и функций должны быть глаголами, быть записанными в 
    смешанном регистре и начинаться с нижнего.
    
        getName(), computeTotalWidth()...
    
5)  Названия пространств имён следует записывать в нижнем регистре.
    
        model::analyzer, io::iomanager, common::math::geometry...
    
6)  Следует называть имена типов в шаблонах одной заглавной буквой.
    
        template <class T>, template <class C, class D> ...

7)  Аббревиатуры и сокращения в именах должны записываться в нижнем регистре.
    
        exportHtmlSource(); // НЕЛЬЗЯ: exportHTMLSource();
        openDvdPlayer();    // НЕЛЬЗЯ: openDVDPlayer();

8)  Членам класса с модификатором private следует присваивать 
    суффикс-подчёркивание.
    
        class SomeClass {
            private:
                int length_;
        };
    
9)  Настраиваемым переменным следует давать то же имя, что и у их типа.
    
        void setTopic(Topic* topic)
            // НЕЛЬЗЯ: void setTopic(Topic* value)
            // НЕЛЬЗЯ: void setTopic(Topic* aTopic)
            // НЕЛЬЗЯ: void setTopic(Topic* t)

        void connect(Database* database)
            // НЕЛЬЗЯ: void connect(Database* db)
            // НЕЛЬЗЯ: void connect(Database* oracleDB)
    
10) Все имена следует записывать по-английски.
    
        fileName;   // НЕ РЕКОМЕНДУЕТСЯ: imyaFayla
    
11) Переменные, имеющие большую область видимости, следует называть длинными 
    именами, имеющие небольшую область видимости — короткими.
    
12) Имена объектов не указываются явно, следует избегать указания названий 
    объектов в именах методов.
    
        line.getLength();   // НЕ РЕКОМЕНДУЕТСЯ: line.getLineLength();
    
13) Слова get/set должны быть использованы везде, где осуществляется прямой 
    доступ к атрибуту.
    
        employee.getName();
        employee.setName(name);

        matrix.getElement(2, 4);
        matrix.setElement(2, 4, value);
    
14) Слово compute может быть использовано в методах, вычисляющих что-либо.
    
        valueSet->computeAverage();
        matrix->computeInverse();
    
15) Слово find может быть использовано в методах, осуществляющих какой-либо 
    поиск.
    
        vertex.findNearestVertex();
        matrix.findMinElement();
    
16) Слово initialize может быть использовано там, где объект или сущность 
    инициализируется.
    
        printer.initializeFontSet();
    
17) Множественное число следует использовать для представления наборов 
    (коллекций) объектов.
    
        vector<Point>  points;
        int            values[];
    
18) Префикс n следует использовать для представления числа объектов.
    
        nPoints, nLines;
    
19) Суффикс No следует использовать для обозначения номера сущности.
    
        tableNo, employeeNo;
        
        // Другой неплохой альтернативой является префикс i: 
        
        iTable, iEmployee;
    
20) Переменным-итераторам следует давать имена i, j, k и т. д.
    
21) Префикс is следует использовать только для булевых (логических) 
    переменных и методов.
    
        isSet, isVisible, isFinished, isFound, isOpen...
        
        // В некоторых ситуациях префикс is лучше заменить на 
        // другой: has, can или should:
        
        bool hasLicense();
        bool canEvaluate();
        bool shouldSort();
    
22) Симметричные имена должны использоваться для соответствующих операций.
    
        get/set, add/remove, create/destroy, start/stop, insert/delete,
        increment/decrement, old/new, begin/end, first/last, up/down, min/max,
        next/previous, old/new, open/close, show/hide, suspend/resume, и т. д.
    
23) Следует избегать дополнительного именования указателей.
    
        Line* line; // НЕ РЕКОМЕНДУЕТСЯ: Line* pLine;
                    // НЕ РЕКОМЕНДУЕТСЯ: Line* linePtr;
    
24) Константы в перечислениях могут иметь префикс — общее имя типа.
    
        enum Color {
            COLOR_RED,
            COLOR_GREEN,
            COLOR_BLUE
        };
    
25) Классам исключений следует присваивать суффикс Exception.
    
        class AccessException
        {
            // ...
        };
    
26) Функциям (методам, возвращающим какие-либо значения) следует давать имена 
    в зависимости от того, что они возвращают, а процедурам — в зависимости от 
    того, что они выполняют (методы void).
    
27) Заголовочным файлам C++ следует давать расширение .h (предпочтительно) либо 
    .hpp. Файлы исходных кодов могут иметь расширения .c++, .C, .cc либо 
    .cpp (рекомендуется).
    
        MyClass.cpp, MyClass.h
    
28) Содержимое файлов не должно превышать 80 колонок.
    
        80 колонок — широко распространённое разрешение для редакторов, 
        эмуляторов терминалов, принтеров и отладчиков; файлы передаются 
        между различными людьми, поэтому нужно придерживаться этих 
        ограничений. Уместная разбивка строк улучшает читаемость при 
        совместной работе над исходным кодом.
    
29) Нельзя использовать специальные символы (например, TAB) и разрывы страниц.
    
30) Незавершённость разбитых строк должна быть очевидна.
    
        totalSum = a + b + c +
                   d + e;

        function (param1, param2,
                  param3);

        setText ("Long line split"
                 "into two parts.");

        for (int tableNo = 0; tableNo < nTables;
             tableNo += tableStep)
        {
            // ...
        }
    
31) Заголовочные файлы должны содержать защиту от вложенного включения.
    
        #ifndef COM_COMPANY_MODULE_CLASSNAME_H
        #define COM_COMPANY_MODULE_CLASSNAME_H
        :
        #endif // COM_COMPANY_MODULE_CLASSNAME_H
    
32) Разделы класса public, protected и private должны быть отсортированы. 
    Все разделы должны быть явно указаны.
    
33) Приведение типов должно быть явным. Никогда не полагайтесь на неявное 
    приведение типов.
    
        floatValue = static_cast<float>(intValue); 
        // НЕЛЬЗЯ: floatValue = intValue;
    
34) Символ указателя или ссылки в языке C++ следует ставить сразу после имени 
    типа, а не с именем переменной.
    
        float* x; // НЕ РЕКОМЕНДУЕТСЯ: float *x; 
        int&   y; // НЕ РЕКОМЕНДУЕТСЯ: int &y;
    
35) Следует избегать использования break и continue в циклах.
    
36) Строго избегайте сложных уловных выражений. Вместо этого вводите 
    булевы переменные.
    
        bool isFinished = (elementNo < 0) || (elementNo > maxElement);
        bool isRepeatedEntry = elementNo == lastElement;
        
        if (isFinished || isRepeatedEntry)
        {
            // ...
        }

        // NOT:
        if ((elementNo < 0) || (elementNo > maxElement)||
             elementNo == lastElement)
        {
            // ...
        }
    
37) Ожидаемую часть следует располагать в части if, исключение — в части else.
    
        bool isOk = readFile (fileName);
        if (isOk)
        {
            // ...
        }
        else
        {
            // ...
        }
    
38) Следует избегать «магических» чисел в коде. Числа, отличные от 0 или 1, 
    следует объявлять как именованные константы.

39) Константы с плавающей точкой следует записывать с десятичной точкой и с 
    указанием по крайней мере одной цифры после запятой.
    
        double total = 0.0;    // НЕ РЕКОМЕНДУЕТСЯ:  double total = 0;
        double speed = 3.0e8;  // НЕ РЕКОМЕНДУЕТСЯ:  double speed = 3e8;

        double sum;
        :
        sum = (a + b) * 10.0;
    
40) Следует использовать «0» вместо «NULL».
    
        NULL является частью стандартной библиотеки C и устарело в C++.
    
41) Основной отступ следует делать в 4 пробела.
    
        for (i = 0; i < nElements; i++)
        {
            a[i] = 0;
        }
    
42) Следует использовать на каждой строке не более одного оператора.
    
        for (i = 0; i < nElements; i++)
        {
            a[i] = 0;
        }
        
        // НЕ РЕКОМЕНДУЕТСЯ
        
        for (i = 0; i < nElements; i++) {
            a[i] = 0;
        }
        
        for (i = 0; i < nElements; i++)
            a[i] = 0;
            
        for (i = 0; i < nElements; i++) { a[i] = 0; }
    
43) Конструкцию switch следует оформлять следующим образом:
    
        switch (condition)
        {
            case ABC :
                statements;
                break;

            case DEF :
                statements;
                break;

            case XYZ :
                statements;
                break;

            default :
                statements;
                break;
        }
    
44) Конструкцию try-catch следует оформлять следующим образом:
    
        try
        {
            statements;
        }
        catch (Exception& exception)
        {
            statements;
        }
    
45) Пробелы:
    
        — Операторы следует отбивать пробелами.
        — После зарезервированных ключевых слов языка C++ следует ставить пробел.
        — После запятых следует ставить пробелы.
        — Двоеточия следует отбивать пробелами.
        — После точек с запятой в цикле for следует ставить пробелы.
    
46) Логические блоки в коде следует отделять пустой строкой.
    
47) Переменные в объявлениях можно выравнивать. (Используйте выравнивание 
    везде, где это улучшает читаемость)
    
        AsciiFile* file;
        int        nPoints;
        float      x, y;
    
48) Используйте // для всех комментариев, включая многострочные.
    
        // Комментарий, расположенный
        // на нескольких строках.
    
49) Комментарии можно заключать в рамки типа:
    
        ////////// Название рамки ////////////////////////////////////////
        // Комментарий для произвольного объекта...                     //
        // ....                                                         //
        // ....                                                         //
        //////////////////////////////////////////////////////////////////

50) Пример оформления кода с использованием пользовательского пространства 
    имен.
    
        namespace block
        {
            // Размер битового блока (кол-во бит)
            const int BLOCK_SIZE = 64;
            
            // Максимальный размер буфера (в блоках)
            const int MAX_BUFFER_SIZE = 50;
            
            // Максимальное количество буферов в массиве
            const int MAX_BUFFER_NUMBER = 50;
            
            // Тип : Битовый блок
            typedef std::bitset<BLOCK_SIZE> Block;
            
            // Тип : Массив битовых блоков
            typedef std::vector<Block> BlockVector;
            
            ////////// struct Buffer /////////////////////////////////////////////////
            // Эта структура представляет из себя буфер, состоящий из битовых       //
            // блоков и являющийся элементом массива RAID.                          //
            //////////////////////////////////////////////////////////////////////////
            
            struct Buffer
            {
                public :
                    
                    BlockVector blocks;             // Массив битовых блоков
                    bool        isCrashed;          // Переменная состояния буфера
                    
                public :
                    
                    // (1) Конструктор
                    Buffer();
        	    
                    // (2) Конструктор копирования
                    Buffer(const Buffer& buffer);
        	    
                    // (3) Перегрузка оператора присваивания
                    Buffer& operator=(const Buffer& buffer);
                    
                    // (4) Вывод в консоль
                    void print();
                    
                    // (5) Изменяет размер буфера
                    void resize(const int& blockNumber);
                    
                    // (6) Задает случайные значения
                    void setRandomValues();
                    
                    // (7) Сбрасывает значение статуса
                    void resetStatus();
                    
                    // (8) Сбрасывает значения всех битов до нуля
                    void reset();
                    
                    // (9) Очищает элементы буфера
                    void clear();
                    
                    // (10) Деструктор
                    ~Buffer();
            };
        }